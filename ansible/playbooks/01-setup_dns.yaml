- name: Bootstrap PVE server
  hosts: dns
  become: true
  roles:
    - pve_server

- name: Setup technitium user and install location
  hosts: dns
  become: true
  tasks:
  - name: Create installation directory
    ansible.builtin.file:
      path: /opt/technitium/dns
      state: directory
      owner: technitium-user
      group: technitium-user
      mode: '0755'

  - name: Set ownership of /etc/dns folder
    ansible.builtin.file:
      path: /etc/dns
      state: directory
      owner: technitium-user
      group: technitium-user
      mode: '0755'
  tags: dns

- name: Install dotnet runtime
  hosts: dns
  become: true
  tasks:
  - name: Check if dotnet runtime is already installed
    ansible.builtin.shell: dotnet --list-runtimes | grep "Microsoft.AspNetCore.App 9.0"
    register: dotnet_check
    ignore_errors: true

  - name: Setup Microsoft repository
    ansible.builtin.shell: |
      wget https://packages.microsoft.com/config/debian/13/packages-microsoft-prod.deb -O packages-microsoft-prod.deb
      dpkg -i packages-microsoft-prod.deb
      rm packages-microsoft-prod.deb
    when: dotnet_check.rc != 0

  - name: Update apt cache
    ansible.builtin.apt:
      update_cache: yes
    when: dotnet_check.rc != 0

  - name: Install dotnet runtime
    ansible.builtin.apt:
      name: aspnetcore-runtime-9.0
      state: present
    when: dotnet_check.rc != 0
  tags: dns

- name: Setup and configure Technitium DNS Server
  hosts: dns
  become: true
  gather_facts: true
  tasks:
  - name: Download and unarchive Technitium DNS Server (if not already installed)
    ansible.builtin.unarchive:
      src: https://download.technitium.com/dns/DnsServerPortable.tar.gz
      dest: /opt/technitium/dns
      owner: technitium-user
      group: technitium-user
      mode: '0755'
      remote_src: yes
      creates: /opt/technitium/dns/DnsServerApp.dll
    register: technitium_unarchive
  
  - name: Copy systemd service file for Technitium DNS Server
    ansible.builtin.copy:
      src: ./files/technitium_dns.service
      dest: /etc/systemd/system/dns.service
    when: technitium_unarchive.changed
  
  - name: Reload systemd daemon
    ansible.builtin.systemd:
      daemon_reload: yes
    when: technitium_unarchive.changed

  - name: Ensure DNS service is started and enabled
    ansible.builtin.service:
      name: dns
      state: started
      enabled: true
  
  - name: Populate service facts
    service_facts:
  tags: dns

- name: Setup Technitium DNS via API
  hosts: dns
  become: false
  gather_facts: true
  tasks:
  - name: Set facts
    ansible.builtin.set_fact:
      api_url: "http://{{ ansible_facts.default_ipv4.address }}"
  
  - name: Read secrets from Infisical
    ansible.builtin.include_role:
      name: infisical
      public: true
    when: true

  - name: Login and get session token
    effectivelywild.technitium_dns.technitium_dns_login:
      api_url: "{{ api_url }}"
      username: "admin"
      password: "admin"
      validate_certs: false
    register: login_result
    ignore_errors: True
  
  - name: Create new user for management
    effectivelywild.technitium_dns.technitium_dns_create_user:
      api_url: "{{ api_url }}"
      api_token: "{{ login_result.token }}"
      username: "schaermu"
      password: "{{ secrets.secrets['MANAGEMENT_PASSWORD'] }}"
      displayName: "Schaermu"
      validate_certs: false
    when: login_result is succeeded

  - name: Give new user admin privileges
    effectivelywild.technitium_dns.technitium_dns_set_user_details:
      api_url: "{{ api_url }}"
      api_token: "{{ login_result.token }}"
      username: "schaermu"
      memberOfGroups:
        - "Administrators"
      validate_certs: false
    when: login_result is succeeded

  - name: Login with new user and refresh session token
    effectivelywild.technitium_dns.technitium_dns_login:
      api_url: "{{ api_url }}"
      username: "schaermu"
      password: "{{ secrets.secrets['MANAGEMENT_PASSWORD'] }}"
      validate_certs: false
    register: login_result
    
  - name: Disable default admin user
    effectivelywild.technitium_dns.technitium_dns_set_user_details:
      api_url: "{{ api_url }}"
      api_token: "{{ login_result.token }}"
      username: "admin"
      disabled: true
      validate_certs: false
  
  - name: Configure blocklists
    effectivelywild.technitium_dns.technitium_dns_set_server_settings:
      api_url: "{{ api_url }}"
      api_token: "{{ login_result.token }}"
      dnsServerDomain: "dns1.lab.schaermu.ch"
      dnsServerLocalEndPoints: 
        - "{{ ansible_facts.default_ipv4.address }}:53"
      blockListUrls:
        - https://raw.githubusercontent.com/StevenBlack/hosts/master/alternates/fakenews-gambling/hosts
        - https://big.oisd.nl/domainswild2
        - https://cdn.jsdelivr.net/gh/hagezi/dns-blocklists@latest/wildcard/multi-onlydomains.txt
      
  - name: Create forward lookup DNS zone for schaermu.ch
    effectivelywild.technitium_dns.technitium_dns_zone:
      api_url: "{{ api_url }}"
      api_token: "{{ login_result.token }}"
      zone: "schaermu.ch"
      type: "Forwarder"
      forwarder: "1.1.1.1"
      initializeForwarder: true
      protocol: "Udp"
      state: "present"
      validate_certs: false
  
  - name: Create internal records for schaermu.ch
    effectivelywild.technitium_dns.technitium_dns_record:
      api_url: "{{ api_url }}"
      api_token: "{{ login_result.token }}"
      zone: "schaermu.ch"
      type: "A"
      name: "{{ item.name }}.schaermu.ch"
      ttl: 3600
      ipAddress: "{{ item.address }}"
      state: "present"
      validate_certs: false
    loop:
      - {name: "nas.lab", address: "192.168.1.40"}
      - {name: "dns1.lab", address: "{{ ansible_facts.default_ipv4.address }}"}
      - {name: "arthur.lab", address: "192.168.1.20"}
      - {name: "proxy.lab", address: "{{ lookup('env', 'TF_VAR_hosts_podman_ip') }}"}
  
  - name: Create CNAME records for wildcard subdomains
    effectivelywild.technitium_dns.technitium_dns_record:
      api_url: "{{ api_url }}"
      api_token: "{{ login_result.token }}"
      zone: "schaermu.ch"
      type: "CNAME"
      name: "*.lab.schaermu.ch"
      ttl: 3600
      cname: "proxy.lab.schaermu.ch."
      state: "present"
      validate_certs: false
  tags: dns

- name: Setup & connect Tailscale
  hosts: dns[0]
  pre_tasks:
  - name: Read secrets from Infisical
    ansible.builtin.include_role:
      name: infisical
      public: true
    when: true
  roles:
  - role: artis3n.tailscale.machine
    vars:
      tailscale_authkey: "{{ secrets.secrets['TAILSCALE_AUTH_KEY'] }}"
  tags: dns

- name: Setup DNS resolver on all hosts
  hosts: [bastion, podman, nas]
  become: true
  tasks:
  - name: Populate service facts
    service_facts:
  
  - name: Get list of DNS servers from inventory
    ansible.builtin.set_fact:
      dns_servers: "{{ groups['dns'] | map('extract', hostvars, ['ansible_facts', 'default_ipv4', 'address']) | list }}"
  
  - name: Configure resolver using resolvectl
    ansible.builtin.shell: |
      resolvectl dns {{ ansible_facts.default_ipv4.interface }} {{ dns_servers | join(' ') }}
      resolvectl domain {{ ansible_facts.default_ipv4.interface }} lab.schaermu.ch
    when: ansible_facts.services['systemd-resolved.service'] is defined and ansible_facts.services['systemd-resolved.service'].state == 'running'

  - name: Configure resolver by writing to /etc/resolv.conf
    ansible.builtin.template:
      src: ./templates/resolv.conf.j2
      dest: /etc/resolv.conf
      mode: '0644'
    vars:
      nameservers: "{{ dns_servers }}"
      search: ["lab.schaermu.ch"]
    when: ansible_facts.services['systemd-resolved.service'] is not defined or ansible_facts.services['systemd-resolved.service'].state != 'running'
  tags: dns